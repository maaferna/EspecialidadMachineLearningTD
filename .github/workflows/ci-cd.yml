name: Multi-project CI

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  ci:
    runs-on: ubuntu-latest

    # Lista de subproyectos (carpetas) sobre las que quieres correr el pipeline
    strategy:
      fail-fast: false
      matrix:
        subdir: [ "Modulo10EvaModularMarcoParra" ]  # agrega más: "OtroProyecto", ...

    # Todo se ejecuta dentro de la subcarpeta elegida
    defaults:
      run:
        shell: bash
        working-directory: ${{ matrix.subdir }}

    permissions:
      contents: read
      packages: write

    env:
      # Nombre base de imagen para GHCR (usa org/repo del repo actual)
      IMAGE_BASE: ghcr.io/${{ github.repository }}/ml-backend-conda
      # Puerto host del runner para no chocar con otros jobs
      HOST_PORT: 8000
      CONTAINER_NAME: api

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Mostrar estructura
        run: |
          echo "== Subproyecto: ${{ matrix.subdir }} =="
          ls -la
          echo
          echo "== Contenido backend =="
          ls -la backend

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set tags
        id: tags
        run: |
          # normaliza el nombre de la subcarpeta para el tag
          SAFE_TAG="$(echo '${{ matrix.subdir }}' | tr '[:upper:]/ ' '[:lower:]--')"
          echo "safe_tag=$SAFE_TAG" >> $GITHUB_OUTPUT
          echo "tag_sha=${{ env.IMAGE_BASE }}:${SAFE_TAG}-sha-${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "tag_latest=${{ env.IMAGE_BASE }}:${SAFE_TAG}-latest" >> $GITHUB_OUTPUT
          echo "TAG_SHA=${{ env.IMAGE_BASE }}:${SAFE_TAG}-sha-${{ github.sha }}"
          echo "TAG_LATEST=${{ env.IMAGE_BASE }}:${SAFE_TAG}-latest"

      - name: Build Docker image
        run: |
          docker build -t "${{ steps.tags.outputs.tag_sha }}" -t "${{ steps.tags.outputs.tag_latest }}" ./backend

      - name: Train model (writes to backend/models)
        run: |
          mkdir -p backend/models
          # Nota: el Dockerfile usa micromamba, así que ejecutamos dentro del entorno
          docker run --rm \
            -v "$PWD/backend/models:/app/models" \
            "${{ steps.tags.outputs.tag_sha }}" \
            micromamba run -n ml-docker-api python -u train_model.py
          ls -lh backend/models

      - name: Run API container
        run: |
          docker rm -f "${CONTAINER_NAME}" 2>/dev/null || true
          docker run -d --name "${CONTAINER_NAME}" \
            -p "${HOST_PORT}:5000" \
            -v "$PWD/backend/models:/app/models" \
            "${{ steps.tags.outputs.tag_sha }}" \
            micromamba run -n ml-docker-api gunicorn -w 2 -b 0.0.0.0:5000 app:app
          # espera breve y muestra logs
          sleep 8
          docker logs --tail=100 "${CONTAINER_NAME}" || true

      - name: Smoke test - GET /
        run: |
          curl -fsS "http://localhost:${HOST_PORT}/" | jq .

      - name: Smoke test - POST /predict (vector nulo)
        run: |
          curl -fsS -X POST "http://localhost:${HOST_PORT}/predict" \
            -H "Content-Type: application/json" \
            -d '{"features":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}' | jq .

      - name: Push image
        run: |
          docker push "${{ steps.tags.outputs.tag_sha }}"
          docker push "${{ steps.tags.outputs.tag_latest }}"

      - name: Upload trained artifacts (optional)
        uses: actions/upload-artifact@v4
        with:
          name: models-${{ matrix.subdir }}
          path: |
            ${{ matrix.subdir }}/backend/models/model*.joblib
            ${{ matrix.subdir }}/backend/models/*.pkl
          if-no-files-found: ignore

      - name: Cleanup containers
        if: always()
        run: |
          docker rm -f "${CONTAINER_NAME}" 2>/dev/null || true
